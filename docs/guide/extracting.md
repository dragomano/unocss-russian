---
outline: deep
---

# Извлечение {#extracting}

UnoCSS работает путём поиска использований утилит в вашей кодовой базе и генерации соответствующего CSS по запросу. Мы называем этот процесс **извлечением**.

## Источники контента {#content-sources}

UnoCSS поддерживает извлечение использований утилит из нескольких источников:

- [Конвейер](#extracting-from-build-tools-pipeline) — Извлечение прямо из конвейера инструментов сборки.
- [Файловая система](#extracting-from-filesystem) — Извлечение из файловой системы путём чтения и отслеживания файлов.
- [Инлайн](#extracting-from-inline-text) — Извлечение из обычного встроенного текста.

Использования утилит, полученные из разных источников, объединяются для генерации итогового CSS.

### Извлечение из конвейера инструментов сборки {#extracting-from-build-tools-pipeline}

Это поддерживается в интеграциях [Vite](/integrations/vite) и [Webpack](/integrations/webpack).

UnoCSS считывает контент, проходящий через конвейер ваших инструментов сборки, и извлекает из него использования утилит. Это наиболее эффективный и точный способ, так как мы интеллектуально извлекаем только то, что действительно используется в вашем приложении, и в процессе извлечения не выполняется никаких дополнительных операций ввода-вывода файлов.

По умолчанию UnoCSS извлекает использования утилит из файлов в вашем конвейере сборки с расширениями `.jsx`, `.tsx`, `.vue`, `.md`, `.html`, `.svelte`, `.astro`, `.marko`, а затем генерирует соответствующий CSS по запросу. Файлы `.js` и `.ts` **НЕ включены по умолчанию**.

Чтобы настроить это поведение, вы можете обновить свой `uno.config.ts`:

```ts [uno.config.ts]
export default defineConfig({
  content: {
    pipeline: {
      include: [
        // по умолчанию
        /\.(vue|svelte|[jt]sx|vine.ts|mdx?|astro|elm|php|phtml|marko|html)($|\?)/,
        // включаем файлы js/ts
        'src/**/*.{js,ts}',
      ],
      // исключаем файлы
      // exclude: []
    },
  },
})
```

Вы также можете добавить магический комментарий `@unocss-include` в индивидуальном порядке в любое место файла, который вы хотите, чтобы UnoCSS просканировал. Если вам необходимо сканировать файлы `*.js` или `*.ts`, добавьте их в конфигурацию, чтобы включить все js/ts файлы в качестве целей сканирования.

```ts
// ./some-utils.js

// так как файлы .js не включены по умолчанию,
// следующий комментарий заставляет UnoCSS принудительно просканировать этот файл.
// @unocss-include
export const classes = {
  active: 'bg-primary text-white',
  inactive: 'bg-gray-200 text-gray-500',
}
```

Аналогично, вы можете добавить `@unocss-ignore`, чтобы пропустить сканирование и трансформацию всего файла.

Если вы хотите, чтобы UnoCSS пропустил блок кода и не выполнял извлечение внутри него, вы можете использовать `@unocss-skip-start` и `@unocss-skip-end`. Обратите внимание, что для корректной работы их необходимо использовать **в паре**.

```html
<p class="text-green text-xl">Зелёный большой</p>

<!-- @unocss-skip-start -->
<!-- `text-red` не будет извлечён -->
<p class="text-red">Red</p>
<!-- @unocss-skip-end -->
```

### Извлечение из файловой системы {#extracting-from-filesystem}

В случаях, когда вы используете интеграции, не имеющие доступа к конвейеру инструментов сборки (например, плагин [PostCSS](/integrations/postcss)), или выполняете интеграцию с бэкенд-фреймворками, где код не проходит через этот конвейер, вы можете вручную указать файлы для извлечения.

```ts [uno.config.ts]
export default defineConfig({
  content: {
    filesystem: [
      'src/**/*.php',
      'public/*.html',
    ],
  },
})
```

Соответствующие файлы будут считываться напрямую из файловой системы и отслеживаться на предмет изменений в режиме разработки.

### Извлечение из инлайн-текста {#extracting-from-inline-text}

Кроме того, вы также можете извлекать использования утилит из инлайн-текста, который может быть получен из других источников.

Вы также можете передать асинхронную функцию для возврата контента. Однако обратите внимание, что эта функция будет вызвана только один раз во время сборки.

```ts [uno.config.ts]
export default defineConfig({
  content: {
    inline: [
      // обычный текст
      '<div class="p-4 text-red">Какой-то текст</div>',
      // асинхронный геттер
      async () => {
        const response = await fetch('https://example.com')
        return response.text()
      },
    ],
  },
})
```

## Ограничения {#limitations}

Поскольку UnoCSS работает **во время сборки**, это означает, что будут сгенерированы и отправлены в ваше приложение только статически представленные утилиты. Утилиты, которые используются динамически или подгружаются из внешних ресурсов во время выполнения (runtime), могут быть **НЕ** обнаружены или не применены.

### Белый список {#safelist}

Иногда вам может понадобиться использовать динамическую конкатенацию, например:

```html
<div class="p-${size}"></div>
<!-- это не сработает! -->
```

Поскольку UnoCSS работает во время сборки, используя статическое извлечение, на этапе компиляции он не может знать все комбинации утилит. Для таких случаев вы можете настроить опцию `safelist`.

```ts [uno.config.ts]
safelist: 'p-1 p-2 p-3 p-4'.split(' ')
```

Соответствующий CSS будет генерироваться всегда:

<!-- eslint-skip -->

```css
.p-1 { padding: 0.25rem; }
.p-2 { padding: 0.5rem; }
.p-3 { padding: 0.75rem; }
.p-4 { padding: 1rem; }
```

Или более гибкий вариант:

```ts [uno.config.ts]
safelist: [
  ...Array.from({ length: 4 }, (_, i) => `p-${i + 1}`),
]
```

Если вы ищете настоящую динамическую генерацию во время выполнения, обратите внимание на пакет [@unocss/runtime](/integrations/runtime).

### Статический список комбинаций {#static-list-combinations}

Ещё один способ обойти ограничение с динамически создаваемыми утилитами — использовать объект, в котором перечислены все комбинации **статически**. Например, если вы хотите сделать так:

```html
<div class="text-${color} border-${color}"></div>
<!-- это не сработает! -->
```

Вы можете создать объект, в котором перечислены все комбинации (при условии, что вы знаете все возможные значения `color`, которые собираетесь использовать)

```ts
// Поскольку они статичны, UnoCSS сможет извлечь их во время сборки
const classes = {
  red: 'text-red border-red',
  green: 'text-green border-green',
  blue: 'text-blue border-blue',
}
```

А затем используйте в своем шаблоне:

```html
<div class="${classes[color]}"></div>
```

### Чёрный список {#blocklist}

По аналогии с `safelist`, вы также можете настроить `blocklist`, чтобы исключить генерацию некоторых утилит. Это полезно для исключения ложных срабатываний при извлечении. В отличие от `safelist`, `blocklist` принимает как строки для точного совпадения, так и регулярные выражения для совпадения по шаблону.

```ts [uno.config.ts]
blocklist: [
  'p-1',
  /^p-[2-4]$/,
]
```

Это исключит генерацию `p-1`, а также `p-2`, `p-3`, `p-4`.
